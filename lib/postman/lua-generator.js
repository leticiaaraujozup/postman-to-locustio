var RequestBodyModes = require('postman-collection').RequestBody.MODES,
    ItemGroup = require('postman-collection').ItemGroup,
    Item = require('postman-collection').Item,
    LuaHelper = require('../lua-helper'),
    util = require('util');

var LuaGenerator = {

  convert: function(postmanCollection) {

    if (!postmanCollection || postmanCollection.items.count() === 0 ) {
      return '# No HTTP/HTTPS transactions have been recorded.';
    }

    var result = [],
        folderRequests,
        requests = [],
        allVariables = [],
        luaRequest;

    result.push(util.format("# Auto-generated by the Load Impact converter"));
    result.push("import time");
    result.push("from locust import HttpLocust, TaskSet, task");

    result.push("")
    result.push("")

    result.push("class UserBehavior(TaskSet):")
    let i = 0;

    postmanCollection.items.each(function(item) {

      if (ItemGroup.isItemGroup(item)) {
        var folder = item;
        if (folder.auth) { throw new Error(' TODO: folder.auth'); }

        result.push(util.format('# %s\n', folder.name));

        folder.items.each(function(folderItem) {
          luaRequest = convertToLuaRequest(folderItem);
          allVariables = allVariables.concat(luaRequest.variables);
          result.push("    @task");
          result.push(util.format("    def test_%d(self):", i++));
          luaRequest.result.split("\n").forEach((line) => {
            result.push("        " + line);
          })
        });

      } else if (Item.isItem(item)) {

        luaRequest = convertToLuaRequest(item);
        allVariables = allVariables.concat(luaRequest.variables);
        result.push("    @task");
        result.push(util.format("    def test_%d(self):", i++));
        luaRequest.result.split("\n").forEach((line) => {
          result.push("        " + line);
        })

      } else {

        throw new Error(' TODO: Implement postCollection item');

      }

    });

    result.push("class WebsiteUser(HttpLocust):")
    result.push("    task_set = UserBehavior")
    result.push("    min_wait = 5000")
    result.push("    max_wait = 9000")

    if (allVariables.length) {

      allVariables = arrayUnique(allVariables);

      result.splice(4, 0, "");
      for (var j = allVariables.length - 1; j >= 0; j--) {

        result.splice(4, 0, util.format("local %s = \"YOUR_VALUE\"", allVariables[j]));

      }
      result.splice(4, 0, "");

    }

    return result.join('\n');

  }

};
function arrayUnique(array) {
    var a = array.concat();
    for(var i=0; i<a.length; ++i) {
        for(var j=i+1; j<a.length; ++j) {
            if(a[i] === a[j])
                a.splice(j--, 1);
        }
    }

    return a;
}


function convertToLuaRequest(item) {

  var request = item.request,
      body = request.body,
      method,
      url,
      data,
      postRequest,
      preRequest,
      auth = request.auth,
      headerHash = {},
      authHeader,
      headers = [];


  // read method & url
  method = request.method;
  url = request.url.toString();


  // read test and preRequest functions
  if (item.events.count() > 0) {

    item.events.each(function(event) {
      // console.log(item.events);
      var script;
      if (event.listen === 'test') {
        script = event.script.exec;
        if (script.length) {
          //Lua commented
          postRequest = util.format("# [[\n%s\n--]]\n", script.join('\n'));
        }
      } else if (event.listen === 'prerequest') {
        script = event.script.exec;
        if (script.length) {
          //Lua commented
          preRequest = util.format("# [[\n%s\n--]]\n", script.join('\n'));
        }
      }
    });

  }


  // get headers & auth into headerHash
  request.headers.each(function(header) {
    headerHash[header.key] = header.value;
  });

  // add or overwrite auth header
  if (auth && auth.type) {

    var AuthenticationManager = moduleExist('./auth/' + auth.type);
    if (AuthenticationManager && AuthenticationManager.enabled) {

      authHeader = AuthenticationManager.header(request);

      // convert headerHash to arrayHeaders
      if (authHeader) {
        delete headerHash.Authorization;
        headers.push(authHeader);
      }
    } else {

      var authenticationComment;
      if (auth.type === 'awsv4' || auth.type === 'hawk' || auth.type === 'oauth1') {

        authenticationComment = util.format("Note: %s dynamic authentication is not supported", auth.type);

      } else if (auth.type === 'digest') {

        authenticationComment = util.format("Note: Refer to %s for dynamic digest authentication", "http://support.loadimpact.com/knowledgebase/articles/174596-http-basic-digest-ntlm-authentication");

      }

      if (authenticationComment) {

        postRequest = postRequest || '';
        postRequest += util.format("# [[\n%s\n--]]\n", authenticationComment);

      }


    }
  }


  headers = headerHash

  // read body
  var bodyData = body[body.mode];
  if (bodyData) {

    if (body.mode === RequestBodyModes.raw) {
      data = LuaHelper.escapeContent(bodyData);
    } else if (bodyData.count() > 0) {
      //body.mode === RequestBodyModes.formdata
      //body.mode === RequestBodyModes.urlencoded
      //should we add default CONTENT-TYPE Header `application/x-www-form-urlencoded`?

      var params = [];
      bodyData.each(function(paramItem) {
        params.push(util.format('%s=%s', encodeURIComponent(paramItem.key), encodeURIComponent(paramItem.value)));
      });

      data = params.join('&');

    }

  }

  return LuaHelper.buildLuaRequest({
    url: url,
    method: method,
    headers: headers,
    data: data,
    preRequest: preRequest,
    postRequest: postRequest,
    sleepTime: 'sleep_time',
    variable: 'response'
  });

}

function moduleExist(name){
  try { return require(name); }
  catch(e) { return false; }
}


module.exports = LuaGenerator;
